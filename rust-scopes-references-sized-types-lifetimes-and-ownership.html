<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Rust Scopes, References, Sized Types, Lifetimes, and Ownership  - maventype</title><meta name="description" content="Scopes in Rust&nbsp; In Rust, scope is an important concept that determines&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="stylesheet" href="https://akbar-mt.github.io/maventype-website/media/plugins/syntaxHighlighter/prism-black.css"><link rel="canonical" href="https://akbar-mt.github.io/maventype-website/rust-scopes-references-sized-types-lifetimes-and-ownership.html"><link rel="alternate" type="application/atom+xml" href="https://akbar-mt.github.io/maventype-website/feed.xml"><link rel="alternate" type="application/json" href="https://akbar-mt.github.io/maventype-website/feed.json"><meta property="og:title" content="Rust Scopes, References, Sized Types, Lifetimes, and Ownership "><meta property="og:site_name" content="maventype"><meta property="og:description" content="Scopes in Rust&nbsp; In Rust, scope is an important concept that determines&hellip;"><meta property="og:url" content="https://akbar-mt.github.io/maventype-website/rust-scopes-references-sized-types-lifetimes-and-ownership.html"><meta property="og:type" content="article"><link rel="preload" href="https://akbar-mt.github.io/maventype-website/assets/dynamic/fonts/publicsans/publicsans.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://akbar-mt.github.io/maventype-website/assets/css/style.css?v=f3255e888ee4af56f3e8437a2c4c99f3"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://akbar-mt.github.io/maventype-website/rust-scopes-references-sized-types-lifetimes-and-ownership.html"},"headline":"Rust Scopes, References, Sized Types, Lifetimes, and Ownership ","datePublished":"2024-08-29T15:16+05:30","dateModified":"2025-02-01T16:58+05:30","description":"Scopes in Rust&nbsp; In Rust, scope is an important concept that determines&hellip;","author":{"@type":"Person","name":"Akbar Pasha","url":"https://akbar-mt.github.io/maventype-website/authors/akbar-pasha/"},"publisher":{"@type":"Organization","name":"Akbar Pasha"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><div class="container"><div class="left-bar"><div class="left-bar__inner"><header class="header"><a class="logo" href="https://akbar-mt.github.io/maventype-website/">maventype </a><a class="logo logo--atbottom" href="https://akbar-mt.github.io/maventype-website/">maventype</a></header></div></div><main class="main post"><article class="content"><div class="content__meta content__meta--attop"><div class="content__meta--attop__inner"><div class="content__maintag"><svg width="20" height="20" aria-hidden="true" focusable="false"><use xlink:href="https://akbar-mt.github.io/maventype-website/assets/svg/svg-map.svg#tag"/></svg> Published in <a href="https://akbar-mt.github.io/maventype-website/tags/rust/" class="metadata__maintag">Rust</a></div></div></div><div class="main__inner"><div class="content__meta"><div class="content__author"><img src="https://www.gravatar.com/avatar/ba4a17531053862a770758548665027f?s&#x3D;240" loading="lazy" height="240" width="240" alt="Akbar Pasha" class="content__author__avatar"><div><a href="https://akbar-mt.github.io/maventype-website/authors/akbar-pasha/" class="content__author__name">Akbar Pasha</a></div></div><div class="content__date"><time datetime="2024-08-29T15:16">Aug 29, 2024</time></div></div><header class="content__header"><h1 class="content__title">Rust Scopes, References, Sized Types, Lifetimes, and Ownership </h1></header><div class="content__entry"><h2 id="scopes-in-rustandnbsplessbrgreater">Scopes in Rust&nbsp;<br></h2><p>In Rust, scope is an important concept that determines where variables are accessible. Let's explore this with some code examples:</p><pre class="line-numbers language-rust"><code>fn main() {
    // This defines `i` in the scope of the main function.
    // It won't be accessible from a different function.
    let i = 5; 
    println!("{i}");

    // This creates a new scope for the loop.
    // The curly braces start a new scope for the variables defined in the loop.
    for i in 1..5 {
        println!("{}", i);
    }

    // You can also create just a scope with curly braces
    // and define variables that are scoped to that block.
    {
        let name = String::new();
        println!("{}", name);
    }
    // This won't compile and will give an error:
    // println!("{}", name);
}</code></pre><p>Understanding scope is crucial for working with references and lifetimes in Rust.<br></p><h2 id="references-in-rust">References in Rust</h2><p>References allow us to give access to a value through another variable. Here's how they work:</p><pre class="line-numbers language-rust"><code>let name = String::from("akbar");
println!("{name}");

// We can create a reference to the above variable
let n = &name;

// `n` gets assigned the address of the value 

// While you often need to explicitly dereference references in Rust,
// certain operations like println! have built-in behavior to
// automatically dereference when it makes sense to do so.
println!("{}", n);
println!("{}", *n);

// This returns the memory address of n
println!("{:p}", n);</code></pre><h2 id="the-display-trait-and-referencesandnbsplessbrgreater">The Display Trait and References&nbsp;<br></h2><p>Let's connect this to the <code>Display</code> trait:</p><pre class="line-numbers language-rust"><code>let name = String::from("akbar");
let n = &name;
println!("{}", n);</code></pre><p>Here's what's happening behind the scenes:</p><ul><li><code>n</code> is a <code>&amp;String</code></li><li><code>println!</code> looks for a <code>Display</code> implementation for <code>&amp;String</code></li><li>It doesn't find one, so it dereferences <code>&amp;String</code> to <code>String</code></li><li>It still doesn't find a <code>Display</code> implementation for <code>String</code>, so it dereferences again</li><li>Now it has a <code>str</code>, which does have a <code>Display</code> implementation</li><li>It uses this implementation to print the string</li></ul><p>This multi-step dereferencing happens automatically, which is why you don't need to write <code>*n</code> explicitly. This automatic dereferencing is due to a feature called "deref coercion", which allows you to use a <code>&amp;String</code> where a <code>&amp;str</code> is expected without explicit dereferencing.</p><h2 id="sized-and-unsized-types-in-rustlessbrgreater">Sized and Unsized Types in Rust<br></h2><h3 id="sized-vs-unsized-typesandnbsplessbrgreater">Sized vs. Unsized Types:&nbsp;<br></h3><ul><li>A sized type is one whose size is known at compile time. For example, <code>i32</code>, <code>f64</code>, or any struct with fields of known size.</li><li>An unsized type is one whose size is not known at compile time. These are also called "dynamically sized types" (DSTs).</li></ul><h2 id="why-str-is-unsized">Why str is Unsized:</h2><p><code>str</code> represents a string slice of any length. Since strings can be of any length, the compiler doesn't know how much memory a <code>str</code> will occupy at compile time.</p><h3 id="why-we-use-andampstr">Why We Use &amp;str:</h3><p>While we can't use <code>str</code> directly (because its size is unknown), we can use a reference to it: <code>&amp;str</code>.</p><p>A reference to an unsized type is itself a sized type. It consists of two parts:</p><ul><li>A pointer to the data</li><li>Additional information about the unsized type (in this case, the length of the string)</li></ul><p>This combination of pointer and metadata is known as a "fat pointer" and has a known size at compile time.</p><h3 id="how-references-make-it-sized">How References Make it Sized:</h3><p>For <code>&amp;str</code>, the reference contains:</p><ul><li>A pointer to the start of the string data</li><li>The length of the string</li></ul><p>This reference has a fixed size (typically two words: one for the pointer, one for the length), which is known at compile time.</p><h3 id="exampleandnbsplessbrgreater">Example&nbsp;<br></h3><pre class="line-numbers language-rust"><code>// let s: str = "Hello, world!";  // This is not allowed!
let s: &str = "Hello, world!"; // This is fine</code></pre><p>In the commented-out line, we can't create a variable of type str directly because Rust wouldn't know how much stack space to allocate for it.</p><p>In the second line, we're creating a reference to a string slice, which has a known size (typically 16 bytes on a 64-bit system: 8 for the pointer, 8 for the length).</p><h2 id="lifetimes">Lifetimes</h2><p>Lifetimes are Rust's way of ensuring that references are valid for as long as they're used. Here's an example that demonstrates a lifetime issue:</p><pre class="line-numbers language-rust"><code>let n: &String;
{
    let name = String::from("akbar");
    n = &name; // this would give an error
}
println!("{n}");</code></pre><p>This code would result in a compile-time error:</p><pre class="line-numbers language-rust"><code>error[E0597]: `name` does not live long enough
   --&gt; src/main.rs:116:9
    |
115 |     let name = String::from("akbar");
    |         ---- binding `name` declared here
116 |     n = &name;
    |         ^^^^^ borrowed value does not live long enough</code></pre><p>The error occurs because <code>name</code> goes out of scope at the end of the inner block, but we're trying to use a reference to it outside of that scope.<br></p><h2 id="ownership">Ownership</h2><p>Rust uses an ownership system to manage memory without a garbage collector. Here are some key points:</p><ul><li>There is only a single owner for each piece of data.</li><li>When the owner goes out of scope, the data is automatically deallocated.</li></ul><p>Let's look at an example:</p><pre class="line-numbers language-rust"><code>let first = String::from("Akbar");
let name = first;

println!("{}", first); // this would give an error</code></pre><p>In this case, the ownership of the string data has moved from first to name. After this move, first is no longer valid to use. Rust prevents us from using moved values to avoid potential bugs.</p><p>If we try to compile this code, we'd get an error message like this:</p><pre class="line-numbers language-rust"><code>error[E0382]: borrow of moved value: `first`
 --&gt; src/main.rs:134:20
  |
131 | let first = String::from("Akbar");
  |     ----- move occurs because `first` has type `String`, which does not implement the `Copy` trait
132 | let name = first;
  |             ----- value moved here
133 | 
134 | println!("{}", first); // this would give error
  |                    ^^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
132 | let name = first.clone();
  |                  ++++++++</code></pre><p>This ownership model applies to data created on the heap, like <code>String</code>. For primitive types that are stored on the stack, Rust uses copying instead of moving:</p><pre class="line-numbers language-rust"><code>let score = 50;
let points = score;
println!("{}", score); // this will print</code></pre><p>In this case, <code>score</code> is copied to <code>points</code>, and both variables remain usable because primitive types implement the <code>Copy</code> trait.</p><p>Understanding these concepts of scopes, references, sized types, lifetimes, and ownership is crucial for writing efficient and safe Rust code. Rust's strict rules might seem challenging at first, but they prevent many common programming errors at compile-time, leading to more robust and secure software.</p></div><footer class="content__footer"><div class="content__last-updated">This article was updated on <time datetime="2025-02-01T16:58">Feb 1, 2025</time></div><div class="content__share"><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fakbar-mt.github.io%2Fmaventype-website%2Frust-scopes-references-sized-types-lifetimes-and-ownership.html" class="js-share facebook tltp tltp--top" aria-label="Facebook" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://akbar-mt.github.io/maventype-website/assets/svg/svg-map.svg#facebook"/></svg> <span>Facebook</span> </a><a href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fakbar-mt.github.io%2Fmaventype-website%2Frust-scopes-references-sized-types-lifetimes-and-ownership.html&amp;via=maventype&amp;text=Rust%20Scopes%2C%20References%2C%20Sized%20Types%2C%20Lifetimes%2C%20and%20Ownership%C2%A0" class="js-share twitter tltp tltp--top" aria-label="Twitter" rel="nofollow noopener noreferrer"><svg><use xlink:href="https://akbar-mt.github.io/maventype-website/assets/svg/svg-map.svg#twitter"/></svg> <span>Twitter</span></a></div></footer></div></article><div class="content__section post__related"><div class="main__inner"><h3 class="content__section__title">Related post</h3><div class="post__related__wrap"><article class="c-card"><div class="c-card__meta"><div class="c-card__author"><img src="https://www.gravatar.com/avatar/ba4a17531053862a770758548665027f?s&#x3D;240" loading="lazy" height="240" width="240" alt="Akbar Pasha"> <a href="https://akbar-mt.github.io/maventype-website/authors/akbar-pasha/">Akbar Pasha</a></div><time datetime="2024-08-31T17:32">Aug 31, 2024 </time><a href="https://akbar-mt.github.io/maventype-website/tags/rust/" class="c-card-tag">Rust</a></div><header class="c-card__header"><h2 class="c-card__title"><a href="https://akbar-mt.github.io/maventype-website/building-a-simple-collection-management-system-in-rust.html">Building a Simple Collection Management System in Rust</a></h2><p>In this blog post, we'll explore how to build a simple collection&hellip;</p></header></article><article class="c-card"><div class="c-card__meta"><div class="c-card__author"><img src="https://www.gravatar.com/avatar/ba4a17531053862a770758548665027f?s&#x3D;240" loading="lazy" height="240" width="240" alt="Akbar Pasha"> <a href="https://akbar-mt.github.io/maventype-website/authors/akbar-pasha/">Akbar Pasha</a></div><time datetime="2024-08-29T16:20">Aug 29, 2024 </time><a href="https://akbar-mt.github.io/maventype-website/tags/rust/" class="c-card-tag">Rust</a></div><header class="c-card__header"><h2 class="c-card__title"><a href="https://akbar-mt.github.io/maventype-website/understanding-move-semantics-copy-and-clone-in-rust.html">Understanding Move Semantics, Copy, and Clone in Rust</a></h2><p>In Rust, when you assign a value to a new variable or&hellip;</p></header></article></div></div></div></main><div class="right-bar"><div class="right-bar__inner"><div class="sidebar"><section class="box authors"><h3 class="box__title">Authors</h3><ul class="authors__cotainer"><li class="authors__item"><a href="https://akbar-mt.github.io/maventype-website/authors/akbar-pasha/" class="authors__image"><img src="https://www.gravatar.com/avatar/ba4a17531053862a770758548665027f?s&#x3D;240" loading="lazy" alt="Akbar Pasha" height="240" width="240" class="authors__img"></a><div><a href="https://akbar-mt.github.io/maventype-website/authors/akbar-pasha/" class="authors__title">Akbar Pasha</a> <span class="authors__meta">Post: 5</span></div></li></ul></section><section class="box tags"><h3 class="box__title">Recommended Topics</h3><ul class="tags__list"><li class="tags__item"><a href="https://akbar-mt.github.io/maventype-website/tags/rust/" class="btn btn--gray">Rust <sup>(5)</sup></a></li></ul></section><div class="box copyright">-</div></div></div></div></div><script defer="defer" src="https://akbar-mt.github.io/maventype-website/assets/js/scripts.min.js?v=b2d91bcadbf5db401b76eb5bb3092eb7"></script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script><script defer="defer" src="https://akbar-mt.github.io/maventype-website/media/plugins/syntaxHighlighter/prism.js"></script><script defer="defer" src="https://akbar-mt.github.io/maventype-website/media/plugins/syntaxHighlighter/prism-line-numbers.min.js"></script><script defer="defer" src="https://akbar-mt.github.io/maventype-website/media/plugins/syntaxHighlighter/clipboard.min.js"></script><script defer="defer" src="https://akbar-mt.github.io/maventype-website/media/plugins/syntaxHighlighter/prism-copy-to-clipboard.min.js"></script></body></html>